import ArgumentParser
import Foundation
import GeneratorCommon
import PBXProj
import XCScheme

extension Generator {
    struct Arguments: ParsableArguments {
        @Argument(
            help: """
Path to the directory where `.xcscheme` files should be written.
""",
            transform: { URL(fileURLWithPath: $0, isDirectory: true) }
        )
        var outputDirectory: URL

        @Argument(
            help: """
Path to where the `xcschememanagement.plist` file should be written.
""",
            transform: { URL(fileURLWithPath: $0, isDirectory: false) }
        )
        var schemeManagementOutputPath: URL

        @Argument(
            help: """
Specifies how schemes are automatically generated:

- `auto`: If no custom schemes are specified, a scheme will be created for \
every buildable target. If custom schemes are provided, no autogenerated \
schemes will be created.
- `all`: A scheme is generated for every buildable target even if custom \
schemes are provided.
- `none`: No schemes are automatically generated.
"""
        )
        var autogenerationMode: AutogenerationMode

        @Argument(help: "Name of the default Xcode configuration.")
        var defaultXcodeConfiguration: String

        @Argument(help: "Absolute path to the Bazel workspace.")
        var workspace: String

        @Argument(help: """
Bazel workspace relative path to where the final `.xcodeproj` will be output.
""")
        var installPath: String

        @Argument(
            help: """
Path to a file that contains a JSON representation of \
`[TargetID: ExtensionPointIdentifier]`.
""",
            transform: { URL(fileURLWithPath: $0, isDirectory: false) }
        )
        var extensionPointIdentifiersFile: URL

        @Argument(
            help: """
Path to a file where each line is a title or script text for an execution \
action, as per <e>.
""",
            transform: { URL(fileURLWithPath: $0, isDirectory: false) }
        )
        var executionActionsFile: URL

        @Argument(
            help: """
Path to a file where each line is a rule-level command-line arugment or \
envionment variable, as per <arg-counts> and <env-counts>.
""",
            transform: { URL(fileURLWithPath: $0, isDirectory: false) }
        )
        var targetsArgsEnvFile: URL

        @Argument(
            help: """
Path to a file where each line is a custom scheme command-line arugment or \
envionment variable, as per <test-command-line-argument-counts>, \
<test-environment-variable-counts>, <run-command-line-argument-counts>, \
<run-environment-variable-counts>, <profile-command-line-argument-counts>, and \
<profile-environment-variable-counts>.
""",
            transform: { URL(fileURLWithPath: $0, isDirectory: false) }
        )
        var schemesArgsEnvFile: URL

        @Option(
            parsing: .upToNextOption,
            help: "Path to the consolidation maps.",
            transform: { URL(fileURLWithPath: $0, isDirectory: false) }
        )
        var consolidationMaps: [URL]

        @Option(
            parsing: .upToNextOption,
            help: "Pairs of <target> <extension-host> target IDs."
        )
        private var targetAndExtensionHosts: [TargetID] = []

        @Option(
            parsing: .upToNextOption,
            help: """
Lists of <target> <additional-target> ... target IDs, with \
--additional-targets-counts determining how many <additional-target> to \
consume per <target>.
"""
        )
        private var additionalTargets: [TargetID] = []

        @Option(
            parsing: .upToNextOption,
            help: """
The number of additional targets per target to consume in --additional-targets.
"""
        )
        private var additionalTargetCounts: [Int] = []

        @OptionGroup var argsAndEnvArguments: ArgsAndEnvArguments

        @OptionGroup var customSchemesArguments: CustomSchemesArguments

        mutating func validate() throws {
            guard targetAndExtensionHosts.count.isMultiple(of: 2) else {
                throw ValidationError("""
<target-and-extension-hosts> (\(targetAndExtensionHosts.count) elements) must \
be <target> and <extension-hosts> pairs.
""")
            }

            let additionalTargetsCount = additionalTargetCounts.count +
                additionalTargetCounts.reduce(0, +)
            guard additionalTargets.count == additionalTargetsCount else {
                throw ValidationError("""
<additional-targets> (\(additionalTargets.count) elements) must have \
\(additionalTargetsCount) elements (\(additionalTargetCounts.count) lists).
""")
            }
        }
    }
}

extension Generator.Arguments {
    func calculateTransitivePreviewReferences(
        targetsByID: [TargetID: Target]
    ) throws -> [TargetID: [BuildableReference]] {
        var keysWithValues: [(TargetID, [BuildableReference])] = []

        var index = 0
        for count in additionalTargetCounts {
            let id = additionalTargets[index]
            index += 1
            let additionalTargets = additionalTargets[index..<(index + count)]
            index += count
            keysWithValues.append(
                (
                    id,
                    try additionalTargets.map { id in
                        return try targetsByID
                            .value(for: id, context: "Additional target")
                            .buildableReference
                    }
                )
            )
        }

        return Dictionary(uniqueKeysWithValues: keysWithValues)
    }

    func calculateExtensionHostIDs() -> [TargetID: [TargetID]] {
        var ret: [TargetID: [TargetID]] = [:]
        for index in stride(
            from: 0,
            to: targetAndExtensionHosts.count - 1,
            by: 2
        ) {
            ret[targetAndExtensionHosts[index], default: []]
                .append(targetAndExtensionHosts[index+1])
        }
        return ret
    }
}
